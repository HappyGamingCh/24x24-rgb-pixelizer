<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>24×24 RGB Pixelizer</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #121a2b;
      --text: #e8eefc;
      --muted: #9db0d1;
      --accent: #4da3ff;
      --border: #2a3756;
      --grid: #1f2a45;
    }
    [hidden]{display:none !important;}
    html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu; background:var(--bg); color:var(--text);}
    .wrap{max-width:1100px;margin-inline:auto;padding:24px}
    h1{font-size:clamp(20px,3vw,28px);margin:0 0 12px}
    p{color:var(--muted);margin:6px 0 18px}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:16px}
    .grid{display:grid;gap:16px;grid-template-columns:1.1fr 1fr}
    @media (max-width: 900px){.grid{grid-template-columns:1fr}}
    .uploader{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    .filelabel{display:inline-flex;align-items:center;gap:10px;background:transparent;border:1px dashed var(--border);color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer}
    .filelabel:hover{border-color:var(--accent)}
    input[type="file"]{display:none}
    .controls{display:flex;gap:16px;align-items:center;flex-wrap:wrap}
    .control{background:#0e1526;border:1px solid var(--border);padding:10px 12px;border-radius:12px;display:flex;align-items:center;gap:10px}
    .control.control-mode{flex-wrap:wrap}
    .radio-group{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .radio{display:inline-flex;align-items:center;gap:6px;font-size:14px;color:var(--muted);cursor:pointer}
    .radio input{accent-color:var(--accent)}
    .stack{display:flex;flex-direction:column;gap:10px}
    .hint{font-size:12px;color:var(--muted)}
    .canvas-wrap{display:grid;gap:12px}
    .canvas-card{background:#0d1424;border:1px solid var(--border);border-radius:16px;padding:12px;display:flex;justify-content:center;align-items:center;min-height:320px}
    canvas{image-rendering: pixelated; image-rendering: crisp-edges; background:#000; border-radius:12px}
    .btns{display:flex;gap:8px;flex-wrap:wrap}
    button{background:var(--accent);border:none;color:#051023;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    button.secondary{background:#12203a;color:var(--text);border:1px solid var(--border)}
    textarea, select{background:#0e1526;border:1px solid var(--border);border-radius:12px;color:var(--text);padding:10px;font:inherit}
    textarea{resize:vertical;min-height:80px}
    select{min-width:120px}
    .small{font-size:12px;color:var(--muted)}
    .legend{display:flex;gap:8px;align-items:center}
    .swatch{width:14px;height:14px;border-radius:3px;border:1px solid var(--border)}
    .text-actions{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .status{font-size:12px;color:var(--muted)}
    .status.error{color:#ff7a7a}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>24×24 RGB Pixelizer</h1>
    <p>อัปโหลดรูปภาพแล้วแปลงให้เป็นภาพพิกเซล <strong>24×24</strong> ใช้สีเพียง <strong>3 สี</strong>: เขียว, แดง, น้ำเงิน พร้อมตัวเลือกแสดงเส้นขอบ และปรับซูมได้</p>

    <div class="panel grid" role="region" aria-label="เครื่องมือแปลงภาพ">
      <div>
        <div class="control control-mode">
          <span>แหล่งข้อมูล:</span>
          <div class="radio-group" role="radiogroup" aria-label="โหมดการแปลง">
            <label class="radio"><input type="radio" name="sourceMode" value="image" checked /> รูปภาพ</label>
            <label class="radio"><input type="radio" name="sourceMode" value="text" /> ข้อความ</label>
          </div>
        </div>

        <div id="imageControls" class="stack" style="margin-top:14px">
          <div class="uploader">
            <label class="filelabel" for="fileInput" aria-label="เลือกไฟล์ภาพ">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 5v14m-7-7h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
              เลือกรูปภาพ
            </label>
            <input id="fileInput" type="file" accept="image/*" />
            <span id="fileName" class="hint">ยังไม่เลือกรูป</span>
          </div>
        </div>

        <div id="textControls" class="stack" style="margin-top:14px" hidden>
          <label for="textInput">ข้อความที่ต้องการแปลง:</label>
          <textarea id="textInput" rows="3" placeholder="เช่น PIXEL ART หรือกด Enter เพื่อขึ้นบรรทัดใหม่"></textarea>
          <div class="hint">เหมาะกับข้อความสั้น ๆ (สูงสุดประมาณ 2–3 ตัวอักษรต่อบรรทัด) สำหรับแคนวาส 24×24 พิกเซล</div>
          <div class="control">
            <label for="textColor">สีของตัวอักษร:</label>
            <select id="textColor">
              <option value="red">แดง</option>
              <option value="green">เขียว</option>
              <option value="blue">น้ำเงิน</option>
            </select>
          </div>
          <div class="text-actions">
            <button id="textBtn" type="button">สร้างภาพพิกเซลจากข้อความ</button>
            <span id="textStatus" class="status">พิมพ์ข้อความแล้วกดปุ่มเพื่อสร้างภาพ</span>
          </div>
        </div>

        <div class="controls" style="margin-top:14px">
          <div class="control">
            <label for="zoom">ซูม:</label>
            <input id="zoom" type="range" min="8" max="48" step="1" value="18" />
            <span id="zoomVal" class="hint">18px ต่อพิกเซล</span>
          </div>
          <div class="control">
            <input id="showGrid" type="checkbox" checked />
            <label for="showGrid">แสดงเส้นขอบแต่ละพิกเซล</label>
          </div>
          <div class="control">
            <label for="bgColor">สีพื้นหลัง:</label>
            <input id="bgColor" type="color" value="#000000" />
          </div>
        </div>

        <div class="btns" style="margin-top:12px">
          <button id="downloadBtn" disabled>ดาวน์โหลดภาพผลลัพธ์</button>
          <button id="resetBtn" class="secondary">ล้างค่า</button>
        </div>
        <p class="small">สีที่ใช้: 
          <span class="legend">
            <span class="swatch" style="background:#00ff00"></span>เขียว
            <span class="swatch" style="background:#ff0000"></span>แดง
            <span class="swatch" style="background:#0000ff"></span>น้ำเงิน
          </span>
        </p>
      </div>
      <div class="canvas-wrap">
        <div class="canvas-card">
          <canvas id="preview" width="432" height="432" aria-label="พื้นที่แสดงผลภาพพิกเซล"></canvas>
        </div>
        <div class="hint">เคล็ดลับ: ลากและวางรูปภาพลงบนหน้านี้ได้เลย</div>
      </div>
    </div>

    <p class="small" style="margin-top:18px">โอเพ่นซอร์ส/ใช้งานบน GitHub Pages ได้ทันที — เพียงวางไฟล์ <code>index.html</code> นี้ใน repository และเปิด Pages</p>
  </div>

  <script>
    // --- Constants ---
    const TARGET_W = 24, TARGET_H = 24;
    const PALETTE = [
      {r:0,   g:255, b:0},   // green
      {r:255, g:0,   b:0},   // red
      {r:0,   g:0,   b:255}, // blue
    ];
    const TEXT_COLORS = {
      red:   PALETTE[1],
      green: PALETTE[0],
      blue:  PALETTE[2],
    };

    // --- Elements ---
    const fileInput = document.getElementById('fileInput');
    const fileName  = document.getElementById('fileName');
    const preview   = document.getElementById('preview');
    const ctx       = preview.getContext('2d');
    const zoomRange = document.getElementById('zoom');
    const zoomVal   = document.getElementById('zoomVal');
    const showGrid  = document.getElementById('showGrid');
    const downloadBtn = document.getElementById('downloadBtn');
    const resetBtn  = document.getElementById('resetBtn');
    const bgColor   = document.getElementById('bgColor');
    const modeRadios = document.querySelectorAll('input[name="sourceMode"]');
    const imageControls = document.getElementById('imageControls');
    const textControls = document.getElementById('textControls');
    const textInput = document.getElementById('textInput');
    const textColor = document.getElementById('textColor');
    const textBtn = document.getElementById('textBtn');
    const textStatus = document.getElementById('textStatus');

    let pixelSize = parseInt(zoomRange.value, 10); // px per logical pixel
    let lastQuantized = null; // Uint8ClampedArray of quantized colors (24x24x4)
    let currentMode = 'image';
    const TEXT_STATUS_DEFAULT = 'พิมพ์ข้อความแล้วกดปุ่มเพื่อสร้างภาพ';

    // Offscreen canvases for processing
    const work = document.createElement('canvas');
    const wctx = work.getContext('2d');

    function setCanvasSize() {
      preview.width = TARGET_W * pixelSize;
      preview.height = TARGET_H * pixelSize;
    }

    function dist2(r1,g1,b1, r2,g2,b2){
      const dr=r1-r2, dg=g1-g2, db=b1-b2; return dr*dr+dg*dg+db*db;
    }

    function quantizeToPalette(imgData){
      const {data, width, height} = imgData;
      const out = new Uint8ClampedArray(width * height * 4);
      for(let i=0;i<data.length;i+=4){
        const r=data[i], g=data[i+1], b=data[i+2];
        const a=data[i+3];
        if(a < 16){
          out[i]=0; out[i+1]=0; out[i+2]=0; out[i+3]=0;
          continue;
        }
        // pick nearest palette color by Euclidean distance in RGB
        let best=0, bestd=Infinity;
        for(let p=0;p<PALETTE.length;p++){
          const c=PALETTE[p];
          const d=dist2(r,g,b, c.r,c.g,c.b);
          if(d<bestd){bestd=d;best=p}
        }
        const c=PALETTE[best];
        out[i]=c.r; out[i+1]=c.g; out[i+2]=c.b; out[i+3]=a;
      }
      return new ImageData(out, width, height);
    }

    function drawQuantized(quantized){
      // Clear with background
      ctx.save();
      ctx.fillStyle = bgColor.value;
      ctx.fillRect(0,0,preview.width,preview.height);
      ctx.restore();

      // Draw each logical pixel as a big rect (no smoothing)
      for(let y=0;y<TARGET_H;y++){
        for(let x=0;x<TARGET_W;x++){
          const idx = (y*TARGET_W + x) * 4;
          const alpha = quantized.data[idx+3];
          if(alpha < 16){ continue; }
          const r = quantized.data[idx];
          const g = quantized.data[idx+1];
          const b = quantized.data[idx+2];
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(x*pixelSize, y*pixelSize, pixelSize, pixelSize);
        }
      }

      if(showGrid.checked){
        ctx.save();
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid') || '#1f2a45';
        ctx.lineWidth = Math.max(1, Math.floor(pixelSize/8));
        // vertical lines
        for(let x=0;x<=TARGET_W;x++){
          const px=x*pixelSize+0.5; // crisp lines
          ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,preview.height); ctx.stroke();
        }
        // horizontal lines
        for(let y=0;y<=TARGET_H;y++){
          const py=y*pixelSize+0.5;
          ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(preview.width,py); ctx.stroke();
        }
        ctx.restore();
      }

      downloadBtn.disabled = false;
    }

    function setTextStatus(message, isError = false){
      if(!textStatus) return;
      textStatus.textContent = message;
      textStatus.classList.toggle('error', !!isError);
    }

    function syncModeRadios(mode){
      modeRadios.forEach(radio => {
        radio.checked = radio.value === mode;
      });
    }

    function setMode(mode){
      currentMode = mode;
      if(mode === 'image'){
        imageControls.hidden = false;
        textControls.hidden = true;
        const name = (fileInput.files && fileInput.files[0]) ? fileInput.files[0].name : '';
        fileName.textContent = name || 'ยังไม่เลือกรูป';
      } else {
        imageControls.hidden = true;
        textControls.hidden = false;
        setTextStatus(TEXT_STATUS_DEFAULT, false);
        if(textInput){ textInput.focus(); }
      }
    }

    function ensureMode(mode){
      if(currentMode !== mode){
        syncModeRadios(mode);
        setMode(mode);
      }
    }

    function createTextImageData(rawText, colorKey){
      if(!rawText) return null;
      const lines = rawText.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
      if(lines.length === 0) return null;

      const color = TEXT_COLORS[colorKey] || TEXT_COLORS.red;

      work.width = TARGET_W;
      work.height = TARGET_H;
      wctx.clearRect(0,0,work.width,work.height);
      wctx.textAlign = 'center';
      wctx.textBaseline = 'alphabetic';

      const targetWidth = TARGET_W * 0.92;
      const targetHeight = TARGET_H * 0.9;
      const spacingRatio = 0.22;

      let chosenSize = 26;
      let metrics = [];
      for(let size=26; size>=6; size--){
        wctx.font = `bold ${size}px sans-serif`;
        const currentMetrics = lines.map(line => {
          const m = wctx.measureText(line);
          const ascent = m.actualBoundingBoxAscent || size * 0.8;
          const descent = m.actualBoundingBoxDescent || size * 0.2;
          return {width:m.width, ascent, descent, height:ascent+descent};
        });
        const maxWidth = Math.max(...currentMetrics.map(m=>m.width));
        const totalHeight = currentMetrics.reduce((sum,m)=>sum+m.height,0) + (lines.length-1)*size*spacingRatio;
        if(maxWidth <= targetWidth && totalHeight <= targetHeight){
          chosenSize = size;
          metrics = currentMetrics;
          break;
        }
        if(size === 6){
          chosenSize = size;
          metrics = currentMetrics;
        }
      }

      wctx.font = `bold ${chosenSize}px sans-serif`;
      if(metrics.length === 0){
        metrics = lines.map(line => {
          const m = wctx.measureText(line);
          const ascent = m.actualBoundingBoxAscent || chosenSize * 0.8;
          const descent = m.actualBoundingBoxDescent || chosenSize * 0.2;
          return {width:m.width, ascent, descent, height:ascent+descent};
        });
      }

      const spacing = chosenSize * spacingRatio;
      const totalHeight = metrics.reduce((sum,m)=>sum+m.height,0) + (lines.length-1)*spacing;
      let y = (TARGET_H - totalHeight)/2 + metrics[0].ascent;

      wctx.fillStyle = '#ffffff';
      lines.forEach((line, idx)=>{
        wctx.fillText(line, TARGET_W/2, y);
        y += metrics[idx].height + spacing;
      });

      const raw = wctx.getImageData(0,0,TARGET_W,TARGET_H);
      const out = new Uint8ClampedArray(raw.data.length);
      for(let i=0;i<raw.data.length;i+=4){
        const alpha = raw.data[i+3];
        if(alpha > 32){
          out[i] = color.r;
          out[i+1] = color.g;
          out[i+2] = color.b;
          out[i+3] = 255;
        } else {
          out[i] = 0;
          out[i+1] = 0;
          out[i+2] = 0;
          out[i+3] = 0;
        }
      }

      return new ImageData(out, TARGET_W, TARGET_H);
    }

    function handleTextConvert(){
      if(!textInput) return;
      const rawText = textInput.value;
      if(!rawText || rawText.trim().length === 0){
        setTextStatus('กรุณากรอกข้อความก่อน', true);
        return;
      }

      setTextStatus('กำลังสร้างภาพ...', false);
      const textImage = createTextImageData(rawText, textColor ? textColor.value : 'red');
      if(!textImage){
        setTextStatus('ไม่สามารถสร้างภาพจากข้อความนี้ได้', true);
        return;
      }

      lastQuantized = textImage;
      setCanvasSize();
      drawQuantized(textImage);
      downloadBtn.disabled = false;
      setTextStatus('แปลงข้อความเรียบร้อย', false);
    }

    async function handleFile(file){
      if(!file) return;
      ensureMode('image');
      fileName.textContent = file.name;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.src = url;
      await img.decode();

      // Fit image into 24×24 by covering the box (center crop) for better pixel art feel
      const srcAR = img.width / img.height;
      const dstAR = TARGET_W / TARGET_H;

      work.width = TARGET_W; work.height = TARGET_H;
      wctx.imageSmoothingEnabled = true;
      let sx=0, sy=0, sw=img.width, sh=img.height;
      if(srcAR > dstAR){
        // image is wider: crop left-right
        sh = img.height;
        sw = sh * dstAR;
        sx = (img.width - sw)/2;
        sy = 0;
      } else {
        // image is taller: crop top-bottom
        sw = img.width;
        sh = sw / dstAR;
        sx = 0;
        sy = (img.height - sh)/2;
      }

      wctx.clearRect(0,0,work.width,work.height);
      wctx.drawImage(img, sx, sy, sw, sh, 0, 0, TARGET_W, TARGET_H);

      const small = wctx.getImageData(0,0,TARGET_W,TARGET_H);
      const quant = quantizeToPalette(small);
      lastQuantized = quant;
      setCanvasSize();
      drawQuantized(quant);

      URL.revokeObjectURL(url);
    }

    // --- Events ---
    fileInput.addEventListener('change', (e)=> handleFile(e.target.files[0]));
    modeRadios.forEach(radio => {
      radio.addEventListener('change', ()=>{
        if(radio.checked){ setMode(radio.value); }
      });
    });
    if(textBtn){ textBtn.addEventListener('click', handleTextConvert); }
    if(textInput){
      textInput.addEventListener('keydown', (e)=>{
        if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
          e.preventDefault();
          handleTextConvert();
        }
      });
      textInput.addEventListener('input', ()=> setTextStatus(TEXT_STATUS_DEFAULT, false));
    }
    if(textColor){
      textColor.addEventListener('change', ()=>{
        if(textStatus){ setTextStatus(TEXT_STATUS_DEFAULT, false); }
      });
    }

    // Drag & drop anywhere
    window.addEventListener('dragover', e=>{ e.preventDefault(); });
    window.addEventListener('drop', e=>{
      e.preventDefault();
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if(f) handleFile(f);
    });

    zoomRange.addEventListener('input', ()=>{
      pixelSize = parseInt(zoomRange.value,10);
      zoomVal.textContent = pixelSize + 'px ต่อพิกเซล';
      if(lastQuantized){ setCanvasSize(); drawQuantized(lastQuantized); }
    });

    showGrid.addEventListener('change', ()=>{ if(lastQuantized){ drawQuantized(lastQuantized); }});
    bgColor.addEventListener('input', ()=>{ if(lastQuantized){ drawQuantized(lastQuantized); }});

    downloadBtn.addEventListener('click', ()=>{
      // Render current canvas to PNG
      const link = document.createElement('a');
      link.download = 'pixelized_24x24_rgb.png';
      link.href = preview.toDataURL('image/png');
      link.click();
    });

    resetBtn.addEventListener('click', ()=>{
      lastQuantized = null;
      ctx.clearRect(0,0,preview.width,preview.height);
      fileInput.value = '';
      fileName.textContent = 'ยังไม่เลือกรูป';
      downloadBtn.disabled = true;
      if(textInput){ textInput.value = ''; }
      setTextStatus(TEXT_STATUS_DEFAULT, false);
      syncModeRadios('image');
      setMode('image');
    });

    // Initial size & background
    setMode('image');
    setCanvasSize();
  </script>
</body>
</html>
