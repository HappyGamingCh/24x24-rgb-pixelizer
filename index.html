<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>24×24 RGB Pixelizer</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #121a2b;
      --text: #e8eefc;
      --muted: #9db0d1;
      --accent: #4da3ff;
      --border: #2a3756;
      --grid: #1f2a45;
    }
    html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu; background:var(--bg); color:var(--text);}
    .wrap{max-width:1100px;margin-inline:auto;padding:24px}
    h1{font-size:clamp(20px,3vw,28px);margin:0 0 12px}
    p{color:var(--muted);margin:6px 0 18px}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:16px}
    .grid{display:grid;gap:16px;grid-template-columns:1.1fr 1fr}
    @media (max-width: 900px){.grid{grid-template-columns:1fr}}
    .uploader{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    .filelabel{display:inline-flex;align-items:center;gap:10px;background:transparent;border:1px dashed var(--border);color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer}
    .filelabel:hover{border-color:var(--accent)}
    input[type="file"]{display:none}
    .controls{display:flex;gap:16px;align-items:center;flex-wrap:wrap}
    .control{background:#0e1526;border:1px solid var(--border);padding:10px 12px;border-radius:12px;display:flex;align-items:center;gap:10px}
    .hint{font-size:12px;color:var(--muted)}
    .canvas-wrap{display:grid;gap:12px}
    .canvas-card{background:#0d1424;border:1px solid var(--border);border-radius:16px;padding:12px;display:flex;justify-content:center;align-items:center;min-height:320px}
    canvas{image-rendering: pixelated; image-rendering: crisp-edges; background:#000; border-radius:12px}
    .btns{display:flex;gap:8px;flex-wrap:wrap}
    button{background:var(--accent);border:none;color:#051023;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    button.secondary{background:#12203a;color:var(--text);border:1px solid var(--border)}
    .small{font-size:12px;color:var(--muted)}
    .legend{display:flex;gap:8px;align-items:center}
    .swatch{width:14px;height:14px;border-radius:3px;border:1px solid var(--border)}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>24×24 RGB Pixelizer</h1>
    <p>อัปโหลดรูปภาพแล้วแปลงให้เป็นภาพพิกเซล <strong>24×24</strong> ใช้สีเพียง <strong>3 สี</strong>: เขียว, แดง, น้ำเงิน พร้อมตัวเลือกแสดงเส้นขอบ และปรับซูมได้</p>

    <div class="panel grid" role="region" aria-label="เครื่องมือแปลงภาพ">
      <div>
        <div class="uploader">
          <label class="filelabel" for="fileInput" aria-label="เลือกไฟล์ภาพ">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 5v14m-7-7h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
            เลือกรูปภาพ
          </label>
          <input id="fileInput" type="file" accept="image/*" />
          <span id="fileName" class="hint">ยังไม่เลือกรูป</span>
        </div>

        <div class="controls" style="margin-top:14px">
          <div class="control">
            <label for="zoom">ซูม:</label>
            <input id="zoom" type="range" min="8" max="48" step="1" value="18" />
            <span id="zoomVal" class="hint">18px ต่อพิกเซล</span>
          </div>
          <div class="control">
            <input id="showGrid" type="checkbox" checked />
            <label for="showGrid">แสดงเส้นขอบแต่ละพิกเซล</label>
          </div>
          <div class="control">
            <label for="bgColor">สีพื้นหลัง:</label>
            <input id="bgColor" type="color" value="#000000" />
          </div>
        </div>

        <div class="btns" style="margin-top:12px">
          <button id="downloadBtn" disabled>ดาวน์โหลดภาพผลลัพธ์</button>
          <button id="resetBtn" class="secondary">ล้างค่า</button>
        </div>
        <p class="small">สีที่ใช้: 
          <span class="legend">
            <span class="swatch" style="background:#00ff00"></span>เขียว
            <span class="swatch" style="background:#ff0000"></span>แดง
            <span class="swatch" style="background:#0000ff"></span>น้ำเงิน
          </span>
        </p>
      </div>
      <div class="canvas-wrap">
        <div class="canvas-card">
          <canvas id="preview" width="432" height="432" aria-label="พื้นที่แสดงผลภาพพิกเซล"></canvas>
        </div>
        <div class="hint">เคล็ดลับ: ลากและวางรูปภาพลงบนหน้านี้ได้เลย</div>
      </div>
    </div>

    <p class="small" style="margin-top:18px">โอเพ่นซอร์ส/ใช้งานบน GitHub Pages ได้ทันที — เพียงวางไฟล์ <code>index.html</code> นี้ใน repository และเปิด Pages</p>
  </div>

  <script>
    // --- Constants ---
    const TARGET_W = 24, TARGET_H = 24;
    const PALETTE = [
      {r:0,   g:255, b:0},   // green
      {r:255, g:0,   b:0},   // red
      {r:0,   g:0,   b:255}, // blue
    ];

    // --- Elements ---
    const fileInput = document.getElementById('fileInput');
    const fileName  = document.getElementById('fileName');
    const preview   = document.getElementById('preview');
    const ctx       = preview.getContext('2d');
    const zoomRange = document.getElementById('zoom');
    const zoomVal   = document.getElementById('zoomVal');
    const showGrid  = document.getElementById('showGrid');
    const downloadBtn = document.getElementById('downloadBtn');
    const resetBtn  = document.getElementById('resetBtn');
    const bgColor   = document.getElementById('bgColor');

    let pixelSize = parseInt(zoomRange.value, 10); // px per logical pixel
    let lastQuantized = null; // Uint8ClampedArray of quantized colors (24x24x4)

    // Offscreen canvases for processing
    const work = document.createElement('canvas');
    const wctx = work.getContext('2d');

    function setCanvasSize() {
      preview.width = TARGET_W * pixelSize;
      preview.height = TARGET_H * pixelSize;
    }

    function dist2(r1,g1,b1, r2,g2,b2){
      const dr=r1-r2, dg=g1-g2, db=b1-b2; return dr*dr+dg*dg+db*db;
    }

    function quantizeToPalette(imgData){
      const {data, width, height} = imgData;
      const out = new Uint8ClampedArray(width * height * 4);
      for(let i=0;i<data.length;i+=4){
        const r=data[i], g=data[i+1], b=data[i+2];
        // pick nearest palette color by Euclidean distance in RGB
        let best=0, bestd=Infinity;
        for(let p=0;p<PALETTE.length;p++){
          const c=PALETTE[p];
          const d=dist2(r,g,b, c.r,c.g,c.b);
          if(d<bestd){bestd=d;best=p}
        }
        const c=PALETTE[best];
        out[i]=c.r; out[i+1]=c.g; out[i+2]=c.b; out[i+3]=255;
      }
      return new ImageData(out, width, height);
    }

    function drawQuantized(quantized){
      // Clear with background
      ctx.save();
      ctx.fillStyle = bgColor.value;
      ctx.fillRect(0,0,preview.width,preview.height);
      ctx.restore();

      // Draw each logical pixel as a big rect (no smoothing)
      for(let y=0;y<TARGET_H;y++){
        for(let x=0;x<TARGET_W;x++){
          const idx = (y*TARGET_W + x) * 4;
          const r = quantized.data[idx];
          const g = quantized.data[idx+1];
          const b = quantized.data[idx+2];
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(x*pixelSize, y*pixelSize, pixelSize, pixelSize);
        }
      }

      if(showGrid.checked){
        ctx.save();
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid') || '#1f2a45';
        ctx.lineWidth = Math.max(1, Math.floor(pixelSize/8));
        // vertical lines
        for(let x=0;x<=TARGET_W;x++){
          const px=x*pixelSize+0.5; // crisp lines
          ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,preview.height); ctx.stroke();
        }
        // horizontal lines
        for(let y=0;y<=TARGET_H;y++){
          const py=y*pixelSize+0.5;
          ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(preview.width,py); ctx.stroke();
        }
        ctx.restore();
      }

      downloadBtn.disabled = false;
    }

    async function handleFile(file){
      if(!file) return;
      fileName.textContent = file.name;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.src = url;
      await img.decode();

      // Fit image into 24×24 by covering the box (center crop) for better pixel art feel
      const srcAR = img.width / img.height;
      const dstAR = TARGET_W / TARGET_H;

      work.width = TARGET_W; work.height = TARGET_H;
      wctx.imageSmoothingEnabled = true;
      let sx=0, sy=0, sw=img.width, sh=img.height;
      if(srcAR > dstAR){
        // image is wider: crop left-right
        sh = img.height;
        sw = sh * dstAR;
        sx = (img.width - sw)/2;
        sy = 0;
      } else {
        // image is taller: crop top-bottom
        sw = img.width;
        sh = sw / dstAR;
        sx = 0;
        sy = (img.height - sh)/2;
      }

      wctx.clearRect(0,0,work.width,work.height);
      wctx.drawImage(img, sx, sy, sw, sh, 0, 0, TARGET_W, TARGET_H);

      const small = wctx.getImageData(0,0,TARGET_W,TARGET_H);
      const quant = quantizeToPalette(small);
      lastQuantized = quant;
      setCanvasSize();
      drawQuantized(quant);

      URL.revokeObjectURL(url);
    }

    // --- Events ---
    fileInput.addEventListener('change', (e)=> handleFile(e.target.files[0]));

    // Drag & drop anywhere
    window.addEventListener('dragover', e=>{ e.preventDefault(); });
    window.addEventListener('drop', e=>{
      e.preventDefault();
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if(f) handleFile(f);
    });

    zoomRange.addEventListener('input', ()=>{
      pixelSize = parseInt(zoomRange.value,10);
      zoomVal.textContent = pixelSize + 'px ต่อพิกเซล';
      if(lastQuantized){ setCanvasSize(); drawQuantized(lastQuantized); }
    });

    showGrid.addEventListener('change', ()=>{ if(lastQuantized){ drawQuantized(lastQuantized); }});
    bgColor.addEventListener('input', ()=>{ if(lastQuantized){ drawQuantized(lastQuantized); }});

    downloadBtn.addEventListener('click', ()=>{
      // Render current canvas to PNG
      const link = document.createElement('a');
      link.download = 'pixelized_24x24_rgb.png';
      link.href = preview.toDataURL('image/png');
      link.click();
    });

    resetBtn.addEventListener('click', ()=>{
      lastQuantized = null;
      ctx.clearRect(0,0,preview.width,preview.height);
      fileInput.value = '';
      fileName.textContent = 'ยังไม่เลือกรูป';
      downloadBtn.disabled = true;
    });

    // Initial size & background
    setCanvasSize();
  </script>
</body>
</html>
